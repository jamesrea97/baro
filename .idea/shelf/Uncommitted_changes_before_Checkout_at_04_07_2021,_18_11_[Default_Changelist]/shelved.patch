Index: app/src/main/java/com/baro/ui/account/AccountActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.baro.ui.account\n\nimport android.app.Activity\nimport android.content.ContentResolver\nimport android.content.Context\nimport android.graphics.Bitmap\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.widget.ImageButton\nimport android.widget.ImageView\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.fragment.app.Fragment\nimport androidx.recyclerview.widget.GridLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport com.baro.R\nimport com.baro.adapters.CourseAdapter\nimport com.baro.constants.AppTags\nimport com.baro.constants.FileEnum\nimport com.baro.constants.PermissionsEnum\nimport com.baro.helpers.AsyncHelpers\nimport com.baro.helpers.PermissionsHelper\nimport com.baro.helpers.interfaces.OnCourseCreate\nimport com.baro.helpers.AsyncHelpers.OnCourseDeleted\nimport com.baro.helpers.interfaceweaks.OnCreatorCourseCredentialsLoad\nimport com.baro.models.Course\nimport com.baro.models.User\nimport com.baro.ui.create.CreateCourseSummaryFragment\nimport com.baro.ui.create.EditCourseSummaryFragment\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport java.lang.ref.WeakReference\nimport java.nio.file.Paths\nimport java.util.*\nimport kotlin.collections.ArrayList\n\n\nclass AccountActivity : AppCompatActivity(), OnCreatorCourseCredentialsLoad,\n    CourseAdapter.OnCourseSelected, OnCourseDeleted, OnCourseCreate{\n    // UI\n    private lateinit var userThumbnailImageView: ImageView\n    private lateinit var followersButton: ImageButton\n    private lateinit var settingsButton: ImageButton\n    private lateinit var createButton: ImageButton\n    private lateinit var courseRecycleView: RecyclerView\n\n    // Model\n    private var user: User? = null\n    private lateinit var courses: ArrayList<Pair<Course, Uri?>>\n    private var courseAdapter: CourseAdapter? = null\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_account)\n\n        // Gets User Credentials\n        user = intent.getParcelableExtra(AppTags.USER_OBJECT.name)\n\n        // Configure UI\n        configureUserThumbnailImageView()\n        configureFollowersButton()\n        configureSettingsButton()\n        configureCreateButton()\n        configureRecycleView()\n\n        // Update UI with User Credentials\n        updateUserCredentials()\n\n\n    }\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    private fun updateUserCredentials() {\n        runBlocking {\n            launch {\n                val weakReference = WeakReference<ContentResolver>(contentResolver)\n                val bitmap = AsyncHelpers().loadUserThumbnail(user?.getThumbnailFile(), weakReference)\n                onUserDataReturned(bitmap) }\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    override fun onBackPressed() {\n        tellFragments()\n        super.onBackPressed()\n    }\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    private fun tellFragments() {\n        val fragments: List<Fragment> = supportFragmentManager.fragments\n        for (f in fragments) {\n            if (f is EditCourseSummaryFragment) {\n                f.onBackPressed()\n            }\n        }\n    }\n\n\n    private fun configureCreateButton() {\n        createButton = findViewById(R.id.btn_create)\n\n        createButton.setOnClickListener {\n            val weakReference = WeakReference<Activity>(this)\n            if (PermissionsHelper.checkAndRequestPermissions(weakReference, PermissionsEnum.CREATE_COURSE_SELECTION)) {\n                val course = Course(UUID.randomUUID(), user)\n                course.setCreationDate(System.currentTimeMillis())\n                val createCourseSummaryFragment: CreateCourseSummaryFragment =\n                    CreateCourseSummaryFragment.newInstance(course)\n\n                supportFragmentManager.beginTransaction()\n                    .add(R.id.fragment_container_view, createCourseSummaryFragment, null)\n                    .addToBackStack(AppTags.CREATE_COURSE_SUMMARY_FRAGMENT.name)\n                    .setReorderingAllowed(true)\n                    .commit()\n            }\n\n\n\n        }\n    }\n\n    private fun configureUserThumbnailImageView() {\n        userThumbnailImageView = findViewById(R.id.im_account)\n    }\n\n    private fun configureFollowersButton() {\n        followersButton = findViewById(R.id.btn_followers)\n        followersButton.setOnClickListener {\n            // TODO - this will display the Users the current user is following - allows for deletion/access straight to their profile\n        }\n    }\n\n    private fun configureSettingsButton() {\n        settingsButton = findViewById(R.id.btn_settings)\n        settingsButton.setOnClickListener {\n            // TODO - this will display account settings: deleting account, changing password if Internet, etc.\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun configureRecycleView() {\n        courseRecycleView = findViewById(R.id.grid_courses)\n        courseRecycleView.layoutManager =\n            GridLayoutManager(this, 2, GridLayoutManager.VERTICAL, false)\n\n        getCoursesFromFiles()\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun getCoursesFromFiles() {\n        val coursePath = Paths.get(\n            getExternalFilesDir(null).toString(),\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.COURSE_DIRECTORY.key\n        )\n        val params = AsyncHelpers.CreatorCourseCredentialsLoad.TaskParams(coursePath, user)\n        AsyncHelpers.CreatorCourseCredentialsLoad(this).execute(params)\n    }\n\n    private fun onUserDataReturned(imageBitmap: Bitmap?) {\n        if (imageBitmap != null) {\n            userThumbnailImageView.setImageBitmap(imageBitmap)\n        }\n    }\n\n\n    override fun onCreatorCourseCredentialsLoad(courses: ArrayList<Pair<Course, Uri?>>) {\n        this.courses = courses\n        updateRecycleView()\n    }\n\n    private fun updateRecycleView() {\n        courseAdapter?.notifyDataSetChanged()\n\n        val weakReference = WeakReference<Context>(this)\n        courseAdapter = CourseAdapter(weakReference, this.courses, this)\n        courseRecycleView.adapter = courseAdapter\n    }\n\n    override fun notifyCourseSelected(course: Course) {\n\n        val weakReference = WeakReference<Activity>(this)\n        if (PermissionsHelper.checkAndRequestPermissions(weakReference, PermissionsEnum.READ_COURSE)) {\n\n            val editCourseSummaryFragment: EditCourseSummaryFragment =\n                EditCourseSummaryFragment.newInstance(course)\n\n            supportFragmentManager.beginTransaction()\n                .add(R.id.fragment_container_view, editCourseSummaryFragment, null)\n                .addToBackStack(AppTags.EDIT_COURSE_SUMMARY_FRAGMENT.name)\n                .setReorderingAllowed(true)\n                .commit()\n        }\n    }\n\n    override fun onCourseDeleted(result: Course?) {\n        var position = -1\n\n        for (course in courses) {\n            if (result?.getCourseUUID() == course.first.getCourseUUID()) {\n                position = courses.indexOf(course)\n            }\n        }\n\n        if (position != -1) {\n            courses.removeAt(position)\n            courseAdapter?.notifyItemRemoved(position)\n            courseAdapter?.notifyItemRangeChanged(position, courses.size)\n\n        }\n\n        supportFragmentManager.popBackStack()\n    }\n\n    override fun onCourseCreate(course: Pair<Course, Uri?>) {\n        courses.add(course)\n        courseAdapter?.notifyItemInserted(courses.size - 1)\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    override fun onResume() {\n        super.onResume()\n        getCoursesFromFiles()\n        courseAdapter?.notifyDataSetChanged()\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/baro/ui/account/AccountActivity.kt	(revision 70cac004d659d6dfd3c79a18b60624c0614f8f29)
+++ app/src/main/java/com/baro/ui/account/AccountActivity.kt	(date 1625414539544)
@@ -110,7 +110,7 @@
                     CreateCourseSummaryFragment.newInstance(course)
 
                 supportFragmentManager.beginTransaction()
-                    .add(R.id.fragment_container_view, createCourseSummaryFragment, null)
+                    .add(R.id.fragment_container_peer_connection, createCourseSummaryFragment, null)
                     .addToBackStack(AppTags.CREATE_COURSE_SUMMARY_FRAGMENT.name)
                     .setReorderingAllowed(true)
                     .commit()
@@ -188,7 +188,7 @@
                 EditCourseSummaryFragment.newInstance(course)
 
             supportFragmentManager.beginTransaction()
-                .add(R.id.fragment_container_view, editCourseSummaryFragment, null)
+                .add(R.id.fragment_container_peer_connection, editCourseSummaryFragment, null)
                 .addToBackStack(AppTags.EDIT_COURSE_SUMMARY_FRAGMENT.name)
                 .setReorderingAllowed(true)
                 .commit()
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\n    <string name=\"app_name\">Baro</string>\n    <string name=\"account\">Account</string>\n    <string name=\"create\">Create</string>\n    <string name=\"share\">Share</string>\n    <string name=\"followers\">Followers</string>\n    <string name=\"settings\">Settings</string>\n    <string name=\"course_name\">Course Name</string>\n    <string name=\"username\">Username</string>\n    <string name=\"share_locally\">Share Locally</string>\n    <string name=\"share_online\">Share Online</string>\n    <string name=\"receive\">Receive</string>\n    <string name=\"send\">Send</string>\n    <string name=\"toast_no_username_found\">No username found.</string>\n    <string name=\"please_enter_valid_username_toast\">Please enter a valid username</string>\n    <string name=\"need_camera_access_toast\">Need camera access</string>\n    <string name=\"write_storage_permission\">Need write external storage access</string>\n    <string name=\"read_storage_permission\">Need read external storage access</string>\n    <string name=\"choose_image_input\">Image Input</string>\n    <string name=\"error_saving_credentials\">Error in saving credentials</string>\n    <string name=\"learn\">Learn</string>\n    <string name=\"error_retrieving_credentials\">Could not retrieve credentials</string>\n    <string name=\"text_choose_category\">Choose Category</string>\n    <string name=\"text_choose_thumbnail\">Choose Thumbnail</string>\n    <string name=\"lenght_course_name_warning_toast\">Course should have a longer name.</string>\n    <string name=\"video_not_saved\">Video was not saved correctly</string>\n    <string name=\"choose_language\">Choose Language</string>\n    <string name=\"flag_name\">Flag Name</string>\n    <string name=\"choose_Categories\">Choose Categories</string>\n    <string name=\"edit\">Edit</string>\n    <string name=\"delete\">Delete</string>\n    <string name=\"no_category\">No Category</string>\n    <string name=\"course_saved_successfully\">Course Saved Successfully!!</string>\n    <string name=\"course_saved_unsuccessfully\">Course not saved :(</string>\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 70cac004d659d6dfd3c79a18b60624c0614f8f29)
+++ app/src/main/res/values/strings.xml	(date 1625414518998)
@@ -32,4 +32,11 @@
     <string name="no_category">No Category</string>
     <string name="course_saved_successfully">Course Saved Successfully!!</string>
     <string name="course_saved_unsuccessfully">Course not saved :(</string>
+    <string name="send_txt">Send</string>
+    <string name="wifidirect_connection">Wifi Connection</string>
+    <string name="wifi_direct_peer_connection">Wifi Direct Sharing</string>
+    <string name="list_of_devices">List of Devices</string>
+    <string name="receive_course">Receive Course</string>
+    <string name="send_course">Send Course</string>
+    <string name="waiting_room">Waiting Room</string>
 </resources>
\ No newline at end of file
Index: app/src/main/java/com/baro/ui/share/p2p/WifiDirectActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.baro.ui.share.p2p\n\nimport android.Manifest\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.IntentFilter\nimport android.content.pm.PackageManager\nimport android.net.wifi.p2p.*\nimport android.os.Bundle\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport com.baro.R\nimport com.baro.constants.AppCodes\nimport com.baro.constants.AppTags\nimport com.baro.helpers.AsyncHelpers\nimport com.baro.helpers.interfaces.OnClientInetAddressReceived\nimport com.baro.helpers.interfaces.OnClientInetAddressSent\nimport com.baro.models.Course\nimport java.net.InetAddress\nimport java.util.*\n\n\n\nclass WifiDirectActivity : AppCompatActivity(), WifiP2pManager.ConnectionInfoListener,\n    OnClientInetAddressReceived, OnClientInetAddressSent {\n\n    private var course: Course? = null\n\n    // WifiDirect\n    private val manager: WifiP2pManager? by lazy(LazyThreadSafetyMode.NONE) {\n        getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager?\n    }\n    private var channel: WifiP2pManager.Channel? = null\n    private var receiver: BroadcastReceiver? = null\n\n    private var isReceiving: Boolean = false\n    private var isSetUp: Boolean? = null\n\n    private var otherDeviceInetAddress: InetAddress? = null\n\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_wifi_direct)\n\n        getUserIntent()\n        configureView()\n\n        initWifiP2P()\n        discoverPeers()\n    }\n\n    private fun getUserIntent() {\n        isReceiving = intent.extras?.get(AppTags.WIFIP2P_INTENT.name) != AppCodes.WIFIP2P_PEER_SEND.code\n\n        if (!isReceiving){\n            course = intent.getParcelableExtra(AppTags.COURSE_OBJECT.name) as Course\n        }\n\n    }\n\n\n    private fun configureView() {\n\n        if (!isReceiving){\n            val peerConnectionSelectionFragment: WifiDirectPeerConnectionSelectionFragment =\n                WifiDirectPeerConnectionSelectionFragment.newInstance()\n            supportFragmentManager.beginTransaction()\n                .add(R.id.fragment_container_peer_connection, peerConnectionSelectionFragment, null)\n                .commit()\n        } else{\n            val peerConnectionWaitingRoomFragment: WifiDirectPeerConnectionWaitingRoomFragment =\n                WifiDirectPeerConnectionWaitingRoomFragment.newInstance()\n            supportFragmentManager.beginTransaction()\n                .add(R.id.fragment_container_peer_connection, peerConnectionWaitingRoomFragment, null)\n                .commit()\n        }\n    }\n\n\n    private fun discoverPeers() {\n        if (ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.ACCESS_FINE_LOCATION\n            ) != PackageManager.PERMISSION_GRANTED\n        ) {\n            // TODO: Consider calling\n            //    ActivityCompat#requestPermissions\n            // here to request the missing permissions, and then overriding\n            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\n            //                                          int[] grantResults)\n            // to handle the case where the user grants the permission. See the documentation\n            // for ActivityCompat#requestPermissions for more details.\n            return\n        }\n        manager?.discoverPeers(channel, object : WifiP2pManager.ActionListener {\n\n            override fun onSuccess() {\n                Toast.makeText(applicationContext, \"DEBUG: Discovering peers\", Toast.LENGTH_LONG)\n                    .show()\n            }\n\n            override fun onFailure(reasonCode: Int) {\n                Toast.makeText(\n                    applicationContext,\n                    \"DEBUG: Cannot discover peers\",\n                    Toast.LENGTH_LONG\n                ).show()\n            }\n        })\n\n    }\n\n    private fun initWifiP2P() {\n        channel = manager?.initialize(this, mainLooper, null)\n        channel?.also { channel ->\n            receiver = manager?.let { WiFiDirectBroadcastReceiver(it, channel, this) }\n        }\n    }\n\n    private val intentFilter = IntentFilter().apply {\n        addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)\n        addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)\n        addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)\n        addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)\n    }\n\n\n    /* register the broadcast receiver with the intent values to be matched */\n    override fun onResume() {\n        super.onResume()\n        receiver?.also { receiver ->\n            registerReceiver(receiver, intentFilter)\n        }\n    }\n\n    /* unregister the broadcast receiver */\n    override fun onPause() {\n        super.onPause()\n        receiver?.also { receiver ->\n            unregisterReceiver(receiver)\n        }\n\n        manager!!.removeGroup(channel, object : WifiP2pManager.ActionListener {\n            override fun onSuccess() {\n                Toast.makeText(\n                    applicationContext,\n                    \"DEBUG: Device disconnected\", Toast.LENGTH_LONG\n                ).show()\n            }\n\n            override fun onFailure(reason: Int) {\n                Toast.makeText(\n                    applicationContext,\n                    \"DEBUG: Could not disconnect devices Reason :$reason\", Toast.LENGTH_LONG\n                ).show()\n            }\n        })\n    }\n\n    // Notify WifiDirectPeerConnectFragment\n    fun wifiDirectStatusUpdate(wifiDirectConnected: Boolean) {\n        if (!isReceiving) {\n            val wifiDirectPeerConnectionFragment = supportFragmentManager\n                .findFragmentById(R.id.fragment_container_peer_connection) as WifiDirectPeerConnectionSelectionFragment?\n            wifiDirectPeerConnectionFragment?.changeWifiDirectStatus(wifiDirectConnected)\n        } else {\n            val wifiDirectPeerWaitingRoomFragment = supportFragmentManager\n                .findFragmentById(R.id.fragment_container_peer_connection) as WifiDirectPeerConnectionWaitingRoomFragment?\n            wifiDirectPeerWaitingRoomFragment?.changeWifiDirectStatus(wifiDirectConnected)\n        }\n\n    }\n\n    fun updateWifiP2PDeviceList(wifiP2pDeviceList: MutableCollection<WifiP2pDevice>) {\n        if(!isReceiving) {\n            val wifiDirectPeerConnectionFragment = supportFragmentManager\n                .findFragmentById(R.id.fragment_container_peer_connection) as WifiDirectPeerConnectionSelectionFragment\n            wifiDirectPeerConnectionFragment.updateWifiP2PDeviceList(wifiP2pDeviceList)\n        }\n    }\n\n\n    fun connectClientDevice(device: WifiP2pDevice) {\n        val config = WifiP2pConfig()\n\n        config.deviceAddress = device.deviceAddress\n        channel?.also { channel ->\n            if (ActivityCompat.checkSelfPermission(\n                    this,\n                    Manifest.permission.ACCESS_FINE_LOCATION\n                ) != PackageManager.PERMISSION_GRANTED\n            ) {\n                // TODO: Consider calling\n                //    ActivityCompat#requestPermissions\n                // here to request the missing permissions, and then overriding\n                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\n                //                                          int[] grantResults)\n                // to handle the case where the user grants the permission. See the documentation\n                // for ActivityCompat#requestPermissions for more details.\n                return\n            }\n            manager?.connect(channel, config, object : WifiP2pManager.ActionListener {\n\n                override fun onSuccess() {\n                    Toast.makeText(\n                        applicationContext,\n                        \"DEBUG: Connection to \" + device.deviceName,\n                        Toast.LENGTH_LONG\n                    ).show()\n                }\n\n                override fun onFailure(reason: Int) {\n                    Toast.makeText(\n                        applicationContext,\n                        \"DEBUG: No connection established\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                }\n            })\n        }\n    }\n\n    override fun onConnectionInfoAvailable(info: WifiP2pInfo?) {\n        if (isSetUp == null) {\n            if (info?.isGroupOwner == true && info?.groupFormed) {\n                Toast.makeText(\n                    applicationContext,\n                    \"DEBUG: GROUP OWNER\",\n                    Toast.LENGTH_LONG\n                ).show()\n                if (!isReceiving) {\n                    val dataReceiver = AsyncHelpers.GroupOwnerReceiveClientInetAddressAsyncTask(this)\n                    dataReceiver.execute()\n                } else {\n                    shareCourse()\n                }\n\n            } else {\n                otherDeviceInetAddress = info?.groupOwnerAddress\n                if (isReceiving) {\n                    val wifiReceiver = WifiDirectEndpoint(\n                        AsyncHelpers.GroupOwnerReceiveClientInetAddressAsyncTask.PORT_GET_CLIENT_INET,\n                        info?.groupOwnerAddress)\n                    val dataSender =\n                        AsyncHelpers.ClientSendInetAddressAsyncTask(wifiReceiver, this)\n                    dataSender.execute()\n                } else {\n                    shareCourse()\n                }\n            }\n        }\n\n\n    }\n\n\n    override fun onClientInetAddressReceived(clientInetAddress: InetAddress?) {\n        Toast.makeText(\n            applicationContext,\n            \"DEBUG: Received Client's IP: \" + clientInetAddress?.hostAddress,\n            Toast.LENGTH_LONG\n\n        ).show()\n        otherDeviceInetAddress = clientInetAddress\n        shareCourse()\n    }\n\n    override fun onClientInetAddressRSent() {\n        shareCourse()\n    }\n\n\n    private fun shareCourse() {\n        isSetUp = true\n        if (isReceiving) {\n            val receiveFragment: WifiDirectCourseReceiveFragment =\n                WifiDirectCourseReceiveFragment.newInstance()\n\n            supportFragmentManager.beginTransaction()\n                .add(R.id.fragment_container_send_receive, receiveFragment, null)\n                .addToBackStack(AppTags.RECEIVE_COURSE_FRAGMENT.name)\n                .setReorderingAllowed(true)\n                .commit()\n\n        } else {\n\n            val sendFragment: WifiDirectCourseSendFragment =\n                WifiDirectCourseSendFragment.newInstance(course, otherDeviceInetAddress)\n\n            supportFragmentManager.beginTransaction()\n                .add(R.id.fragment_container_send_receive, sendFragment, null)\n                .addToBackStack(AppTags.SEND_COURSE_FRAGMENT.name)\n                .setReorderingAllowed(true)\n                .commit()\n        }\n\n    }\n\n\n\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/baro/ui/share/p2p/WifiDirectActivity.kt	(revision 70cac004d659d6dfd3c79a18b60624c0614f8f29)
+++ app/src/main/java/com/baro/ui/share/p2p/WifiDirectActivity.kt	(date 1625414686584)
@@ -55,7 +55,7 @@
         isReceiving = intent.extras?.get(AppTags.WIFIP2P_INTENT.name) != AppCodes.WIFIP2P_PEER_SEND.code
 
         if (!isReceiving){
-            course = intent.getParcelableExtra(AppTags.COURSE_OBJECT.name) as Course
+            course = intent.getParcelableExtra(AppTags.COURSE_OBJECT.name) as Course?
         }
 
     }
Index: app/src/main/java/com/baro/helpers/AsyncHelpers.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.baro.helpers\n\nimport android.content.ContentResolver\nimport android.content.Context\nimport android.graphics.Bitmap\nimport android.graphics.ImageDecoder\nimport android.net.Uri\nimport android.os.AsyncTask\nimport android.os.Build\nimport androidx.annotation.RequiresApi\nimport com.baro.constants.CategoryEnum\nimport com.baro.constants.FileEnum\nimport com.baro.constants.JSONEnum\nimport com.baro.helpers.interfaces.*\nimport com.baro.helpers.interfaceweaks.OnCreatorCourseCredentialsLoad\nimport com.baro.models.Country\nimport com.baro.models.Course\nimport com.baro.models.User\nimport org.json.JSONArray\nimport org.json.JSONObject\nimport java.io.File\nimport java.lang.ref.WeakReference\nimport java.nio.file.Path\nimport java.nio.file.Paths\nimport java.util.*\nimport kotlin.collections.ArrayList\nimport kotlin.collections.HashMap\n\n\nclass AsyncHelpers {\n    /**\n     * With this class you can call the following methods:\n     * VerifyUserCredentials(callback)\n     */\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    fun verifyUserCredentials(file: File?): User? {\n\n\n        val userMetaDataPath = Paths.get(file.toString(),\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.META_DATA_FILE.key)\n\n\n        val userThumbnailPath = Paths.get(file.toString(),\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.PHOTO_THUMBNAIL_FILE.key)\n\n        val userMetaDataFile = FileHelper.getFileAtPath(userMetaDataPath)\n        val userThumbnailFile = FileHelper.getFileAtPath(userThumbnailPath)\n\n        var user: User? = null\n\n        if (userMetaDataFile != null) {\n            val contentMetaData = FileHelper.readFile(userMetaDataFile)\n            val jsonMetaData = contentMetaData?.let { JSONHelper.createJSONFromString(it) }\n\n            user = if (userThumbnailFile != null && userThumbnailFile.length() > 0) {\n                User(\n                    UUID.fromString(jsonMetaData?.get(JSONEnum.USER_UUID_KEY.key) as String),\n                    jsonMetaData[JSONEnum.USER_NAME_KEY.key] as String,\n                    userThumbnailFile\n                )\n            } else {\n                User(\n                    UUID.fromString(jsonMetaData?.get(JSONEnum.USER_UUID_KEY.key) as String),\n                    jsonMetaData[JSONEnum.USER_NAME_KEY.key] as String)\n            }\n        }\n        return user\n\n    }\n\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    fun userCredentialsSave(username: String, path: String, photoUri: Uri?, weakReference: WeakReference<Context>): Boolean {\n        savePhotoUri(photoUri, weakReference.get())\n        return saveCredentials(username, path)\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    private fun saveCredentials(username: String, path: String): Boolean {\n\n        val credentialDetails = HashMap<String?, String?>()\n        val userUUID = UUID.randomUUID()\n        credentialDetails[JSONEnum.USER_NAME_KEY.key] = username\n        credentialDetails[JSONEnum.USER_UUID_KEY.key] = userUUID.toString()\n        val jsonCredentials = JSONHelper.createJSONFromHashMap(credentialDetails)\n        val userMetaDataPath = Paths.get(\n            path,\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.META_DATA_FILE.key\n        )\n        val userMetaDataFile = FileHelper.createFileAtPath(userMetaDataPath)\n        return FileHelper.writeToFile(userMetaDataFile, jsonCredentials.toString())\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.P)\n    private fun savePhotoUri(photoUri: Uri?, context: Context?) {\n        if (photoUri != null) {\n            if (context != null) {\n                val bitmap = ImageDecoder.decodeBitmap(ImageDecoder.createSource(context.contentResolver, photoUri))\n                val userThumbnailPicturePath = Paths.get(\n                    context.getExternalFilesDir(null).toString(),\n                    FileEnum.USER_DIRECTORY.key,\n                    FileEnum.PHOTO_THUMBNAIL_FILE.key)\n                val file = File(userThumbnailPicturePath.toString())\n                FileHelper.writeBitmapToFile(file, bitmap)}\n\n\n        }\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    fun loadUserThumbnail(thumbnailFile: File?, weakReferenceContentResolver: WeakReference<ContentResolver>): Bitmap? {\n        val content = weakReferenceContentResolver.get()\n        return if (thumbnailFile != null && thumbnailFile.exists()) {\n            val source = ImageDecoder.createSource(content!!, Uri.fromFile(thumbnailFile))\n            ImageDecoder.decodeBitmap(source)\n        } else {\n            null\n        }\n        }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    fun courseCredentialsSave(course: Course?, imageUri: Uri?, context: WeakReference<Context>): Boolean {\n        if (course != null) {\n            saveCredentials(course, context)\n        }\n\n        // Save Photo URI\n        savePhotoUri(imageUri, course, context)\n\n        return true\n\n\n\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun saveCredentials(course: Course, context: WeakReference<Context>) {\n\n        val course = course\n        val courseMetadata = HashMap<String?, String?>()\n\n        courseMetadata[JSONEnum.USER_NAME_KEY.key] = course?.getCreator()?.getUserUUID().toString()\n        courseMetadata[JSONEnum.COURSE_NAME_KEY.key] = course?.getCourseName()\n        courseMetadata[JSONEnum.COURSE_UUID_KEY.key] = course?.getCourseUUID().toString()\n        courseMetadata[JSONEnum.COURSE_CREATION_DATETIME.key] = course.getCreationDate()?.toString()\n        val isoCode = course.getCourseCountry()?.getIsoCode()\n        if (isoCode == null) {\n            courseMetadata[JSONEnum.COURSE_LANGUAGE.key] = \"null\"\n        } else {\n            courseMetadata[JSONEnum.COURSE_LANGUAGE.key] = course.getCourseCountry()?.getIsoCode()\n        }\n        courseMetadata[JSONEnum.COURSE_CATEGORY.key] = JSONArray(course.getCourseCategory().toString()).toString()\n        courseMetadata[JSONEnum.COURSE_SLIDES.key] = JSONArray(course.getSlides().toString()).toString()\n\n        val courseMetaDataPath = Paths.get(\n            context.get()?.getExternalFilesDir(null).toString(),\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.COURSE_DIRECTORY.key,\n            course?.getCourseUUID().toString(),\n            FileEnum.META_DATA_FILE.key\n        )\n\n        val courseMetaDataFile = FileHelper.createFileAtPath(courseMetaDataPath)\n        val courseJSONMeta = JSONHelper.createJSONFromHashMap(courseMetadata)\n\n\n        FileHelper.writeToFile(courseMetaDataFile, courseJSONMeta.toString())\n    }\n\n    @RequiresApi(Build.VERSION_CODES.P)\n    private fun savePhotoUri(photoUri: Uri?, course: Course?, context: WeakReference<Context>) {\n        if (photoUri != null) {\n\n            val bitmap = ImageDecoder.decodeBitmap(ImageDecoder.createSource(context.get()?.contentResolver!!, photoUri))\n            val userThumbnailPicturePath = Paths.get(context.get()?.getExternalFilesDir(null).toString(),\n                FileEnum.USER_DIRECTORY.key,\n                FileEnum.COURSE_DIRECTORY.key,\n                course?.getCourseUUID().toString(),\n                FileEnum.PHOTO_THUMBNAIL_FILE.key)\n            val file = File(userThumbnailPicturePath.toString())\n\n            FileHelper.writeBitmapToFile(file, bitmap)\n        }\n    }\n\n\n    class CreatorCourseCredentialsLoad(private var callback: OnCreatorCourseCredentialsLoad) : AsyncTask<CreatorCourseCredentialsLoad.TaskParams, Void?, ArrayList<Pair<Course, Uri?>>>() {\n        @RequiresApi(Build.VERSION_CODES.P)\n        override fun doInBackground(vararg params: TaskParams?): ArrayList<Pair<Course, Uri?>>? {\n            var courses = ArrayList<Pair<Course, Uri?>>()\n\n            val path = params[0]?.path\n            val coursesFile = FileHelper.createDirAtPath(path)\n            val user = params[0]?.user\n            if (coursesFile.listFiles() != null) {\n                for (courseFolder in coursesFile.listFiles()) {\n\n                    if (courseFolder.isDirectory) {\n                        val jsonFilePath = Paths.get(courseFolder.toString(), FileEnum.META_DATA_FILE.key)\n\n                        val jsonFile = jsonFilePath.toFile()\n\n                        // Retrieve content file\n                        val contents = FileHelper.readFile(jsonFile)\n\n                        if (contents != null) {\n                            val jsonContents = JSONHelper.createJSONFromString(contents!!)\n\n                            // Course UUID\n                            val courseUUID = jsonContents?.get(JSONEnum.COURSE_UUID_KEY.key)\n                            // Course Name\n                            val courseName = jsonContents?.get(JSONEnum.COURSE_NAME_KEY.key)\n                            // Category\n                            val categoryJSON = JSONArray(jsonContents?.get(JSONEnum.COURSE_CATEGORY.key).toString())\n                            // Language\n                            val language = jsonContents?.get(JSONEnum.COURSE_LANGUAGE.key)\n                            // Timestamp\n                            val courseCreationTimestamp = jsonContents?.get(JSONEnum.COURSE_CREATION_DATETIME.key).toString().toLong()\n                            // Slides\n                            val slidesJSON = JSONArray(jsonContents?.get(JSONEnum.COURSE_SLIDES.key).toString())\n\n                            // Creation course\n                            val course = Course(UUID.fromString(courseUUID as String?), user)\n\n                            //  Adding course name\n                            course.setCourseName(courseName as String)\n                            // Adding Course Category\n                            course.setCourseCategory(CategoryEnum.getCategoriesFromJSONArray(categoryJSON as JSONArray))\n                            // Adding Course language\n                            if (language.toString() == \"null\") {\n                                course.setCourseCountry(Country(null))\n                            } else {\n                                course.setCourseCountry(Country(language.toString()))\n\n                            }\n                            // Adding timestamp\n                            course.setCreationDate(courseCreationTimestamp)\n\n                            // Adding Slides\n                            course.setSlidesFromJSONArray(slidesJSON)\n\n                            // Thumbnail\n                            val imagePath = Paths.get(courseFolder.toString(), FileEnum.PHOTO_THUMBNAIL_FILE.key)\n                            val imageFile = imagePath.toFile()\n                            val imageUri = Uri.fromFile(imageFile)\n\n                            val pair = Pair<Course, Uri>(course, imageUri)\n                            courses.add(pair)\n                        }\n                    }\n                }\n            }\n\n            var arrayListResults = ArrayList<Pair<Course, Uri?>>()\n\n            if (courses.size > 1) {\n                courses.sortedBy { it.first }\n            }\n            for (course in courses) {\n                arrayListResults.add(course)\n            }\n            return arrayListResults\n\n        }\n\n        @RequiresApi(Build.VERSION_CODES.P)\n        override fun onPostExecute(result: ArrayList<Pair<Course, Uri?>>) {\n            callback.onCreatorCourseCredentialsLoad(result)\n        }\n\n        class TaskParams(var path: Path?, var user: User?)\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    fun videoUriSave(outputFile: File?, videoUri: Uri?, weakReferenceContentResolver: WeakReference<ContentResolver>): File? {\n        if (outputFile != null && outputFile.exists()) {\n            if (videoUri != null) {\n                return FileHelper.copyVideoToFile(outputFile, videoUri, weakReferenceContentResolver.get())\n            }\n        }\n        return null\n    }\n\n\n    fun updateJSONFile(courseMetaFile: File, slideHashMap: java.util.HashMap<String, java.util.ArrayList<String>>): Boolean {\n\n        val contents = FileHelper.readFile(courseMetaFile)\n\n        val jsonContents = JSONHelper.createJSONFromString(contents!!)\n\n        for ((key, value) in slideHashMap) {\n            jsonContents!!.put(key, value)\n        }\n        return FileHelper.writeToFile(courseMetaFile, jsonContents.toString())\n    }\n\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    fun deleteCourse(rootDir: File?, course: Course): Boolean {\n        if (rootDir?.exists() == true) {\n            val coursePath = Paths.get(rootDir.toString(),\n            FileEnum.USER_DIRECTORY.key,\n            FileEnum.COURSE_DIRECTORY.key,\n            course.getCourseUUID().toString())\n            val courseFile = coursePath.toFile()\n            FileHelper.deleteFile(courseFile)\n            return true} else {return false}\n    }\n\n\n\n    interface OnCourseDeleted {\n        fun onCourseDeleted(result: Course?)\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/baro/helpers/AsyncHelpers.kt	(revision 70cac004d659d6dfd3c79a18b60624c0614f8f29)
+++ app/src/main/java/com/baro/helpers/AsyncHelpers.kt	(date 1625414445641)
@@ -7,6 +7,7 @@
 import android.net.Uri
 import android.os.AsyncTask
 import android.os.Build
+import android.util.Log
 import androidx.annotation.RequiresApi
 import com.baro.constants.CategoryEnum
 import com.baro.constants.FileEnum
@@ -16,10 +17,15 @@
 import com.baro.models.Country
 import com.baro.models.Course
 import com.baro.models.User
+import com.baro.ui.share.p2p.WifiDirectEndpoint
 import org.json.JSONArray
 import org.json.JSONObject
-import java.io.File
+import java.io.*
 import java.lang.ref.WeakReference
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.ServerSocket
+import java.net.Socket
 import java.nio.file.Path
 import java.nio.file.Paths
 import java.util.*
@@ -332,4 +338,213 @@
     }
 
 
+
+    class GroupOwnerReceiveClientInetAddressAsyncTask(
+        private var callback: OnClientInetAddressReceived
+
+    ) :
+        AsyncTask<String?, Void, InetAddress?>() {
+
+        companion object {
+            val PORT_GET_CLIENT_INET = 8988
+        }
+
+        @Override
+        override fun onPostExecute(result: InetAddress?) {
+            callback.onClientInetAddressReceived(result)
+        }
+
+        override fun doInBackground(vararg p0: String?): InetAddress? {
+            return try {
+                val serverSocket = ServerSocket(PORT_GET_CLIENT_INET)
+                val client = serverSocket.accept();
+                val clientInetAddress = client.inetAddress
+                serverSocket.close();
+                return clientInetAddress
+            } catch (e: IOException) {
+                null;
+            }
+        }
+    }
+
+    class ClientSendInetAddressAsyncTask(
+        private var serverEndPoint: WifiDirectEndpoint,
+        private var callback: OnClientInetAddressSent
+    ) :
+        AsyncTask<Void?, InetAddress?, InetAddress?>() {
+        private val SOCKET_TIMEOUT = 5000
+        override fun doInBackground(vararg p0: Void?): InetAddress? {
+            val socket = Socket()
+            try {
+                socket.bind(null)
+                socket.connect(
+                    InetSocketAddress(serverEndPoint.ip, serverEndPoint.port),
+                    SOCKET_TIMEOUT
+                )
+            } catch (e: IOException) {
+
+            } finally {
+                if (socket != null) {
+                    if (socket.isConnected) {
+                        try {
+                            socket.close()
+                        } catch (e: IOException) {
+                            e.printStackTrace()
+                        }
+                    }
+                }
+            }
+            return socket.inetAddress
+        }
+
+
+        @Override
+        override fun onPostExecute(result: InetAddress?) {
+            callback.onClientInetAddressRSent()
+        }
+    }
+
+
+    class ReceiveCourseAsyncTask(
+        private var weakContext: WeakReference<Context>,
+        private var callback: OnCourseReceived
+    ) :
+        AsyncTask<Void?, Boolean?, Boolean?>() {
+        companion object {
+            val PORT_GET_COURSE = 9989
+        }
+
+        @Override
+        override fun onPostExecute(result: Boolean?) {
+            callback.onCourseReceived(result)
+        }
+
+        @RequiresApi(Build.VERSION_CODES.O)
+        override fun doInBackground(vararg p0: Void?): Boolean? {
+            return try {
+                val serverSocket = ServerSocket(PORT_GET_COURSE)
+                val client = serverSocket.accept();
+
+
+                val inputStream = client.getInputStream();
+
+                val dis = DataInputStream(inputStream)
+                val courseSize = dis.readLong()
+                val courseUUID = dis.readUTF()
+                callback.retrieveSize(courseSize)
+                val courseZipPath = Paths.get(
+                    weakContext.get()?.getExternalFilesDir(null).toString(),
+                    FileEnum.LEARN_DIRECTORY.key,
+                    "$courseUUID.zip"
+                )
+                val courseFileDestination = Paths.get(
+                    weakContext.get()?.filesDir.toString(),
+                    FileEnum.LEARN_DIRECTORY.key,
+                    courseUUID
+                )
+                val courseTempZipFile = FileHelper.createFileAtPath(courseZipPath)
+
+                writeToFile(inputStream, courseTempZipFile!!);
+                serverSocket.close();
+
+                FileHelper.unzip(courseTempZipFile, courseFileDestination.toString())
+            } catch (e: IOException) {
+                false
+            }
+        }
+
+        // TODO remove this
+        private fun writeToFile(inputStream: InputStream?, courseZipFile: File): Boolean {
+            val buf = ByteArray(1024)
+            var len: Int
+            var currentSize = 0
+            try {
+                val outStream: OutputStream = FileOutputStream(courseZipFile)
+                while (inputStream!!.read(buf).also { len = it } != -1) {
+                    currentSize += 1024
+                    outStream.write(buf, 0, len)
+                    callback.sendProgress(currentSize)
+                }
+                inputStream.close()
+            } catch (e: IOException) {
+                Log.d("Not saved file", e.toString())
+                return false
+            }
+            return true
+        }
+
+    }
+
+
+    class SendCourseAsyncTask(
+        private var receiverEndPoint: WifiDirectEndpoint,
+        private var callback: OnCourseSent
+    ) :
+        AsyncTask<SendCourseAsyncTask.TaskParams?, Boolean?, Boolean?>() {
+        private val SOCKET_TIMEOUT = 5000
+        override fun doInBackground(vararg p0: SendCourseAsyncTask.TaskParams?): Boolean? {
+            val courseZipFile = p0[0]?.courseZipFile
+            val courseUUID = p0[0]?.courseUUID
+            val socket = Socket()
+
+            try {
+                socket.bind(null)
+                socket.connect(
+                    InetSocketAddress(receiverEndPoint.ip, receiverEndPoint.port),
+                    SOCKET_TIMEOUT
+                )
+                val stream: OutputStream = socket.getOutputStream()
+
+
+                // Send course UUID
+                val dos = DataOutputStream(stream)
+                courseZipFile?.length()?.let { dos.writeLong(it) }
+                dos.flush()
+                dos.writeUTF(courseUUID.toString())
+                dos.flush()
+
+                var `is`: InputStream? = null
+                try {
+                    `is` = FileInputStream(courseZipFile)
+                } catch (e: FileNotFoundException) {
+                }
+                copyFile(`is`, stream)
+            } catch (e: IOException) {
+                Log.i("FAILED SEND COURSE", e.toString())
+                return false
+            } finally {
+                if (socket != null) {
+                    if (socket.isConnected) {
+                        try {
+                            socket.close()
+                        } catch (e: IOException) {
+                            e.printStackTrace()
+                        }
+                    }
+                }
+            }
+            return true
+        }
+
+        private fun copyFile(inputStream: InputStream?, out: OutputStream): Boolean {
+            val buf = ByteArray(1024)
+            var len: Int
+            try {
+                while (inputStream?.read(buf).also { len = it!! } != -1) {
+                    out.write(buf, 0, len)
+                }
+                out.close()
+                inputStream?.close()
+            } catch (e: IOException) {
+                return false
+            }
+            return true
+        }
+        class TaskParams(
+            var courseZipFile: File?,
+            var courseUUID: UUID?
+        )
+
+    }
+
 }
